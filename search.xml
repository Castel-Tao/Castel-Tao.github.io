<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>ANOVA方差分析</title>
      <link href="/2020/07/14/anova-fang-chai-fen-xi/"/>
      <url>/2020/07/14/anova-fang-chai-fen-xi/</url>
      
        <content type="html"><![CDATA[<h2 id="吐槽"><a href="#吐槽" class="headerlink" title="吐槽"></a>吐槽</h2><p>我发现很多统计学术语根本没有统一，这都啥和啥呀，难怪我总学不懂。</p><p>比如这ANOVA里一个名词：有叫离差平方和的，有叫平方和的，偏差平方和，差平方和，差方和，我特喵的了！</p><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>​    R.A.Fisher发明，虽然ANOVA（Analysis of Variance）叫做方差分析，但它的目的是<strong>检验每个组的平均数是否相同</strong>（敲黑板！）。也就是说，ANOVA的零假设（null hypothesis）是H<sub>0</sub>: μ<sub>A</sub>=μ<sub>B</sub>=μ<sub>C</sub>。我们是想看三组抽样是否来自同一个总体，方差分析一般用于两个及两个以上样本均数差别的显著性检验。</p><p>​    e.g.  我们想研究某种药物在不同剂量下对人们的作用。我们可能会将病人随机分为同等大小的三组，A组每天吃一片，B组每天吃两片，C组每天吃三片。因为我们只研究这个药品计量对病人的影响，所以是<strong>单因素方差分析</strong>。如果想要加入别的因素，例如，年龄，就需要用到<strong>多因素方差分析了</strong>。在上述实验中，我们给了三种不同的计量，所以这个药物计量因素下有三个<strong>水平（level）</strong>。实验结束以后，你老板问你，这三组病人的表现有显著的区别吗？这个时候，你就可以使用ANOVA来回答你老板的问题啦。</p><h2 id="方差分析的假设"><a href="#方差分析的假设" class="headerlink" title="方差分析的假设"></a>方差分析的假设</h2><p>​    使用ANOVA需要满足一定的假设，如果你的实验不能满足ANOVA的假设，那你需要考虑别的分析方法或者改变实验设计。ANOVA有主要有以下6个假设：</p><ol><li>y变量为连续变量</li><li>有一个包含2个及以上分类，且组别间相互独立的x变量</li><li>有一个包含2个及以上分类，且组别间相互独立的x变量</li><li>方差的同质性（homogeneity of variance）。可以理解为每组样本背后的总体（也叫族群）都有相同的方差；</li><li>每一次抽样都是独立的。</li><li>每组内没有明显的异常值</li></ol><h2 id="这里是正文（单因素方差分步骤）"><a href="#这里是正文（单因素方差分步骤）" class="headerlink" title="这里是正文（单因素方差分步骤）"></a>这里是正文（单因素方差分步骤）</h2><h3 id="1-建立假设"><a href="#1-建立假设" class="headerlink" title="1. 建立假设"></a>1. 建立假设</h3><p>​    H0: μ1=μ2=…=μc</p><p>​    H1: μ1，μ2，…，μc不全相等。</p><h3 id="2-计算样本均值和方差"><a href="#2-计算样本均值和方差" class="headerlink" title="2.计算样本均值和方差"></a>2.计算样本均值和方差</h3><p><img src="https://raw.githubusercontent.com/Castel-Tao/Picbed_PicGo/master/2020.6/20200713232619.png" alt=""></p><h3 id="3-计算误差"><a href="#3-计算误差" class="headerlink" title="3.计算误差"></a>3.计算误差</h3><p><strong>总离差平方和 (Sum of Squares  for Total: SST)</strong>：这是全部观测值$X_{ij}$与总均值$\bar{X}的离差平方和，反映了全部观测值相对于总平均数的分散程度。</p><p><strong>组间离差平方和 (Sum of Squares  for Factor A: SSA)</strong>：这是衡量组间误差的方法，即单因素下各水平的均值$\bar{X_i}$与总均值$\bar{X}$的离差平方和，反应各水平的样本均值之间的分散程度。</p><p><strong>组内离差平方和 (Sum of Squares  for Error: SSE)</strong>：这是衡量组内误差的方法，即各水平的观测值$\bar{X_{ij}}$与其相应均值$\bar{X_i}$的离差平方和，反映了各相同水平下观测值的分散程度，由于组内误差只包含随机误差，因此组内离差平方和实际上反映了随机误差的大小。</p><p><img src="https://raw.githubusercontent.com/Castel-Tao/Picbed_PicGo/master/2020.6/20200713232515.png" alt=""></p><p><strong>即：SST = SSA + SSE</strong></p><p><strong>上面这个公式，亲测相等，好神奇！</strong></p><p>同样自由度也是：</p><p><strong>DFt = DFa + DFe</strong></p><p>好神奇 +1</p><h3 id="4-计算MSE和MSB"><a href="#4-计算MSE和MSB" class="headerlink" title="4.计算MSE和MSB"></a>4.计算MSE和MSB</h3><p>​    组间均方（mean squared between, MSB），相当于每个族群相对于总体的方差；<strong>就是MSA啦</strong>。</p><p>​    组内均方（mean squared error, MSE），也就是每个分布自身的方差。</p><p><img src="https://raw.githubusercontent.com/Castel-Tao/Picbed_PicGo/master/2020.6/20200714091340.jpg" alt=""></p><p>用上一步计算出的离差平方和分别除以对应的自由度即可。</p><h3 id="5-构造F统计量检验"><a href="#5-构造F统计量检验" class="headerlink" title="5.构造F统计量检验"></a>5.构造F统计量检验</h3><p>​    <img src="https://www.zhihu.com/equation?tex=F%3D%5Cfrac%7BMSB%7D%7BMSE%7D" alt="[公式]"></p><p>一共三种情况：</p><ol><li>MSB大，MSE小，F统计量大。说明组间方差远远大于组内方差，拒绝H0。</li><li>MSB小，MSE大，F统计量小。要么组间分布比较近，要么组间分布远但是组内range大，所以都无法拒绝H0。</li><li>MSB和MSE差不多，F统计量一般。不好说，具体能不能拒绝H0要看F统计量的值。</li></ol><p>PS: 貌似MSB服从卡方分布，MSE也服从卡方分布，所以它们的比值服从F分布要用F检验。</p><h3 id="6-Summary：方差分析表"><a href="#6-Summary：方差分析表" class="headerlink" title="6. Summary：方差分析表"></a>6. Summary：方差分析表</h3><p><img src="https://raw.githubusercontent.com/Castel-Tao/Picbed_PicGo/master/2020.6/20200714110930.jpg" alt=""></p><p>这表格里MSA就是MSB，因为来自不同的参考文献，我懒得改了。</p><h2 id="和t-检验的区别"><a href="#和t-检验的区别" class="headerlink" title="和t-检验的区别"></a>和t-检验的区别</h2><ol><li><p>Ttest检验一般针对的是对来自同一分布的数据的均值进行检验，即检验该组数据的分布的均值是否为0,（可以构造统计量，验证分布的均值是其他值）。它重点比较的是这组数据分布的均值与你给他的均值，区别的显著性，如检验一组人的身高是否为之前的值等等。</p></li><li><p>Ttest2检验一般针对的是对来自两个不同样本的分布的分布均值的检验，原始零假设是均值相等，他不关心这两组数据具体来自于什么分布，比如，一组人的身高和体重数据，该检验假设的是这两组分布的均值是否相等，即身高和体重的平均数是否相等。</p></li><li><p>单因素ANOVA<br>单因素方差分析，是用来研究一个控制变量的不同水平是否对观测变量产生了显著影响。通俗地讲就是分析变量x的变化对变量y的影响的显著性，所以一般变量之间存在某种影响关系的，验证一种变量的变化对另一种变量的影响显著性的检验。</p><p>一般的，方差分析都是配对的。<br>如果从计算来看，独立样本之间不需要进行计算，只在本组中进行计算均值、标准差等，而方差分析中，要计算数据之间的组间差异和组内差异等。</p></li><li><p>多因素方差分析<br>多因素方差分析即分析多种因素对某一变量的影响有多大的统计分析。而协方差分析是多种影响因素下，在不考虑某一种因素下，其他因素对该变量的影响有多大。比如，玉米的销量、玉米的价格、爆米花的价格（例子不是很好，但大概就是这个意思，就是a对b有相应，b又对c有影响，但a对c不一定有影响），就是爆米花的价格越高，那么玉米的销量也是 越多的，所以它们之间成正比关系。但这显然是没有相关性的。因为爆米花的价格和玉米的销量均和玉米的温度有关，针对这类问题的分析时要用协方差分</p></li></ol><p>   以上来自：<a href="https://blog.csdn.net/lvsehaiyang1993/java/article/details/80397850" target="_blank" rel="noopener">https://blog.csdn.net/lvsehaiyang1993/java/article/details/80397850</a></p><p>   <strong>查了一些其他资料，反而感觉越来越懵了</strong>，anyway 先放着。</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://zhuanlan.zhihu.com/p/57896471" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/57896471</a></p><p><a href="http://math.sjtu.edu.cn/faculty/chengwang/files/2015spring/方差分析.pdf" target="_blank" rel="noopener">http://math.sjtu.edu.cn/faculty/chengwang/files/2015spring/%E6%96%B9%E5%B7%AE%E5%88%86%E6%9E%90.pdf</a></p><p><a href="https://zhuanlan.zhihu.com/p/33357167" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/33357167</a></p><p><a href="https://www.cnblogs.com/ljhdo/p/10818526.html" target="_blank" rel="noopener">https://www.cnblogs.com/ljhdo/p/10818526.html</a></p><p><a href="https://www.youtube.com/watch?v=t4j3nZp5Kgw" target="_blank" rel="noopener">https://www.youtube.com/watch?v=t4j3nZp5Kgw</a></p><p><a href="https://books.google.co.kr/books?id=BSdaDwAAQBAJ&pg=PA170&lpg=PA170&dq=SSE是什么的缩写&source=bl&ots=j4GNNnAS02&sig=ACfU3U19xUClIy6zgRbvaHz_BDHYmjDGyA&hl=zh-CN&sa=X&ved=2ahUKEwjzv9bE1MvqAhUb7WEKHVSlCoIQ6AEwCHoECAkQAQ#v=onepage&q=SSE是什么的缩写&f=false" target="_blank" rel="noopener">https://books.google.co.kr/books?id=BSdaDwAAQBAJ&amp;pg=PA170&amp;lpg=PA170&amp;dq=SSE%E6%98%AF%E4%BB%80%E4%B9%88%E7%9A%84%E7%BC%A9%E5%86%99&amp;source=bl&amp;ots=j4GNNnAS02&amp;sig=ACfU3U19xUClIy6zgRbvaHz_BDHYmjDGyA&amp;hl=zh-CN&amp;sa=X&amp;ved=2ahUKEwjzv9bE1MvqAhUb7WEKHVSlCoIQ6AEwCHoECAkQAQ#v=onepage&amp;q=SSE%E6%98%AF%E4%BB%80%E4%B9%88%E7%9A%84%E7%BC%A9%E5%86%99&amp;f=false</a></p><p><a href="https://blog.csdn.net/lvsehaiyang1993/java/article/details/80397850" target="_blank" rel="noopener">https://blog.csdn.net/lvsehaiyang1993/java/article/details/80397850</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> R </tag>
            
            <tag> statistics </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>群体间遗传分化度量值Fst</title>
      <link href="/2020/06/25/qun-ti-jian-fen-hua-du-liang-fst-zhi/"/>
      <url>/2020/06/25/qun-ti-jian-fen-hua-du-liang-fst-zhi/</url>
      
        <content type="html"><![CDATA[<h2 id="F-统计量、Fst和Gst"><a href="#F-统计量、Fst和Gst" class="headerlink" title="F-统计量、Fst和Gst"></a>F-统计量、Fst和Gst</h2><p><strong>遗传距离（Genetic distance）</strong>：又称“遗传差异”，指不同种群或物种之间的基因差异程度，并且以某种数值进行度量，通常用Fst值反映<strong>群体</strong>遗传变异的尺度。</p><p><strong>F-统计量</strong>是针对一对等位基因提出的，F统计量主要有（Fis，Fif，Fst）三种。</p><p>如果基因座上存在复等位基因时，Nei（1973）定义了不用同源配子结合的相关性概念的基因差异分化系数（gene differentiation coefficient，<strong>Gst</strong>）。</p><p><strong>Fst</strong>：群体间遗传分化指数，又称为固定系数。反映群体等位基因杂合性水平，用于衡量种群分化程度。<strong>群体遗传学中衡量群体间分化程度的指标有很多种，最常用的就是Fst指数</strong>。</p><p>这个值是种群分化和遗传距离的一种度量方法，<strong>分化指数越大，差异越大</strong>。适用于亚群体间多样性的比较。</p><p>Fst是针对<strong>一对等位基因</strong>，如果基因座上存在复等位基因，则需要用Gst衡量。</p><h2 id="Fst意义"><a href="#Fst意义" class="headerlink" title="Fst意义"></a>Fst意义</h2><p>Fst取值范围[0,1]，最大值为1，表明等位基因在各地方群体中固定，两个群体完全独立；最小值为0，意味着不同地方群体遗传结构完全一致，群体间没有分化，群体间自由interbreeding。</p><p><strong>Wright</strong>（1978）建议，</p><p>Fst为0 ~ 0.05，群体间遗传分化很小，可不考虑群体间遗传分化；</p><p>Fst为0.05 ~ 0.15，群体间存在中等程度遗传分化；</p><p>Fst为0.15 ~ 0.25，群体间遗传分化较大；</p><p>Fst值在0.25以上，群体间有很大遗传分化。</p><h2 id="Fst应用"><a href="#Fst应用" class="headerlink" title="Fst应用"></a>Fst应用</h2><p>Fst可用于计算SNP位点在不同群体中的分化程度（或固定程度），野生种亚群和栽培种亚群间的Fst可反映维位点受人工选择程度。是一种以<strong>哈温平衡为前提</strong>的种群遗传学统计方法。</p><p>计算步骤如下：</p><ol><li><p>测定群体数目及群体规模</p></li><li><p>分别计算群体及亚群体中某一位点上的等位基因频率和基因型频率</p></li><li><p>计算种群期望杂合度（H<del>T</del>）和亚群预计杂合度（H<del>S</del>）</p></li><li><p>计算Fst</p></li></ol><h2 id="Fst的计算"><a href="#Fst的计算" class="headerlink" title="Fst的计算"></a>Fst的计算</h2><h3 id="杂合度的概念"><a href="#杂合度的概念" class="headerlink" title="杂合度的概念"></a>杂合度的概念</h3><p>要清晰明白上述过程，首先要理解杂合度这个概念：</p><p>设某群体中一对等位基因，a=0.5，A=0.5，Aa杂合度=0.5，最大；</p><p>若另一个群体中，a=0.4，A=0.6，则Aa杂合度=2 x 0.4 x 0.6 = 0.48，稍小了一些；</p><p>第三个群体，a=0.2，A=0.8，则Aa杂合度=2 x 0.2 x 0.8 = 0.32，更小。</p><p>由上可见，杂合度越小，种群越纯净；杂合度高，种群越不纯净。</p><h3 id="F-统计量计算公式"><a href="#F-统计量计算公式" class="headerlink" title="F-统计量计算公式"></a>F-统计量计算公式</h3><p>Fit：种群的总近交系数</p><p>Fst：群体内基因分化系数</p><p>Fis：种群内近交系数， FIS，是HI相对于HS减少量的比值，即地方群体的平均近交系数。</p><p>Hi：整个总体所观察到的杂合体频率平均值。（把所有亚群体当作一个总的整体来看的时候）</p><p>Hs：几个亚群体的期望杂合度的平均值。</p><p>Ht：把所有亚群体当作一个总的整体来看的时候，这个总群体中的期望杂合度。且这个总的群体满足HW平衡(He).</p><p>Fis = (Hs - Hi)/Hs = 1-(Hi/Hs) ; FIS，是HI相对于HS减少量的比值，即地方群体的平均近交系数。</p><p>Fst = (Ht - Hs)/Ht = 1-(Hs/Ht) ; FST，是HS相对于HT减少量的比值，即有亲缘关系地方群体间的平均近交系数。</p><p>Fit = (Ht - Hi)/Ht = 1-(Hi/Ht) ; FIT，是HI相对于HT减少量的比值，即整个群体的平均近交系数。</p><table><thead><tr><th><strong>Level of population hierarchy</strong></th><th><strong>F-statistic</strong></th></tr></thead><tbody><tr><td>Among demes within group</td><td><img src="https://raw.githubusercontent.com/Castel-Tao/Picbed_PicGo/master/2020.6/20200705155435.gif" alt=""></td></tr><tr><td>Among groups within population</td><td><img src="https://raw.githubusercontent.com/Castel-Tao/Picbed_PicGo/master/2020.6/20200705155528.gif" alt=""></td></tr><tr><td>Among demes within population</td><td><img src="https://raw.githubusercontent.com/Castel-Tao/Picbed_PicGo/master/2020.6/20200705155525.gif" alt=""></td></tr></tbody></table><h2 id="Examples"><a href="#Examples" class="headerlink" title="Examples"></a>Examples</h2><h3 id="Example-1"><a href="#Example-1" class="headerlink" title="Example 1"></a>Example 1</h3><p>理论上要估算FST，需要以下步骤：</p><ul><li>找出每个亚群的等位基因频率。</li><li>查找复合群体的平均等位基因频率</li><li>计算每个亚群的杂合度（2pq）</li><li>计算这些亚群杂合度的平均值，这是HS。</li><li>根据总体等位基因频率计算杂合度，这是HT。</li><li>最后，计算FST =（HT-HS）/ HT</li></ul><p><img src="https://raw.githubusercontent.com/Castel-Tao/Picbed_PicGo/master/2020.6/20200621123429.png" alt=""></p><p>在得到每个群体中等位基因的频率后:</p><p>首先第一步是计算每个亚群的杂合度H，这一步简单H=2<em>p</em>q （p和q是对应群体中等位基因的频率）</p><p>第二步计算这些亚群杂合度的平均值HS，取三个不同种群中的H值，除去平均数3，得到结果</p><p>第三步，计算群体等位基因频率，和上述方法类似，取每个等位基因在对应种群中的频率叠加除去平均数。</p><p>第四步，计算所有群体中的杂合度HT，使用2pq，p和q是群体中的等位基因频率，在第三步骤已经算好了。</p><p>最后，根据计算公式算出Fst。</p><p>在实际中，当然不可能用手工对每个位点进行这样的计算，怎样在电脑中分析FST等值？</p><h4 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h4><p>当然了，实际中我们并不需要像上述例子那样逐个计算。等位基因频率的信息都藏在snp calling后的vcf中，再使用恰当的工具就可以快速计算出Fst。下面给大家介绍一种比较popular的计算Fst的方法（还有其他方法不限于一种），使用vcftools：</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true">##对每一个SNP变异位点进行计算</span>vcftools --vcf test.vcf --weir-fst-pop 1_population.txt --weir-fst-pop 2_population.txt  --out p_1_2—single<span class="token comment" spellcheck="true">##按照区域来计算</span>vcftools --vcf test.vcf --weir-fst-pop 1_population.txt --weir-fst-pop 2_population.txt  --out p_1_2_bin --fst-window-size 500000 --fst-window-step 50000<span class="token comment" spellcheck="true"># test.vcf是SNP calling 过滤后生成的vcf 文件；</span><span class="token comment" spellcheck="true"># p_1_2_3 生成结果的prefix</span><span class="token comment" spellcheck="true"># 1_population.txt是一个文件包含同一个群体中所有个体，一般每行一个个体。个体名字要和vcf的名字对应。</span><span class="token comment" spellcheck="true"># 2_population.txt 包含了群体二中所有个体。</span><span class="token comment" spellcheck="true">#计算的窗口是500kb，而步长是50kb （根据你的需其可以作出调整）。我们也可以只计算每个点的Fst，去掉参数（--fst-window-size 500000 --fst-window-step 50000）即可。</span></code></pre><p>分别对不同结果进行图形绘制</p><pre class=" language-R"><code class="language-R">##图1library(ggplot2)data<-read.table("test1.out.windowed.weir.fst",header=T)sc3 = subset(data,CHROM=="Gm01")p <- ggplot(sc3,aes(x=BIN_END/1000000,y=WEIGHTED_FST)) + geom_point(size=0.5, colour="blue") + xlab("Physical distance (Mb)")+ ylab("Fst") + ylim(-1,1)p + theme_bw()##图2library(ggplot2)data<-read.table("test.out.weir.fst",header=T)sc3 = subset(data,CHROM=="Gm01")p <- ggplot(sc3,aes(x=POS,y=WEIR_AND_COCKERHAM_FST)) + geom_point(size=0.5, colour="blue") + xlab("Physical distance (Mb)")+ ylab("Fst") + ylim(-1,1)p + theme_bw()</code></pre><p><img src="https://raw.githubusercontent.com/Castel-Tao/Picbed_PicGo/master/2020.6/20200625000105.png" alt=""></p><p><img src="https://raw.githubusercontent.com/Castel-Tao/Picbed_PicGo/master/2020.6/20200625000111.png" alt=""></p><p>可以看到两幅图还是基本对应的，然后对一些接近1，与大部分点偏离比较高的点可以将其与功能注释相结合，还有一些选择压力分析的工具相结合，寻找出其对应的基因，观察该基因是否是被选择。Pi也是选择分析中一个很要的参数，这一部分内容有时间这一点以后再补回来。</p><h3 id="Example-2"><a href="#Example-2" class="headerlink" title="Example 2"></a>Example 2</h3><table><thead><tr><th></th><th>AA</th><th>Aa</th><th>aa</th></tr></thead><tbody><tr><td>种群1</td><td>125</td><td>250</td><td>125</td></tr><tr><td>种群2</td><td>50</td><td>30</td><td>20</td></tr><tr><td>种群3</td><td>100</td><td>500</td><td>400</td></tr></tbody></table><p>表格表示为三个种群中一个等位基因的存在情况。</p><p>第一步，计算种群大小：</p><p>种群1: 500</p><p>种群2: 100</p><p>种群3: 1000</p><p>第二步，计算等位基因的频率：</p><p>p1=(125*2+250)/1000=0.5</p><p>q1=1-p1=0.5</p><p>p2=(50*2+30)/200=0.65</p><p>q2=1-p2=0.35</p><p>p3=(100*2+500)/200=0.35</p><p>q3=1-p3=0.65</p><p>第三步，计算哈温平衡下预期基因型：</p><p>种群1: E(AA)=500<em>0.5</em>0.5=125(与实际相等)</p><p>E(Aa)=500<em>0.5</em>0.5*2=250(与实际相等)</p><p>E(aa)=500<em>0.5</em>0.5=125(与实际相等)</p><p>种群2： E(AA)=100<em>0.65</em>0.65=42.25(比实际小7.75)</p><p>E(Aa)=100<em>0.65</em>0.35*2=45.5(比实际多15.5)</p><p>E(aa)=100<em>0.35</em>0.35=12.25(比实际小7.75)</p><p>种群3: E(AA)=1000<em>0.35</em>0.35=122.5(比实际多22.5)</p><p>E(Aa)=1000<em>0.35</em>0.65*2=455(比实际小45)</p><p>E(aa)=1000<em>0.65</em>0.65=422.5(比实际多22.5)</p><p>种群1的 预期=实际，完美适合；</p><p>种群2的 预期比实际少15.5个纯合子，也可以理解为实际比预期多15.5个纯合子，可能是近交导致；</p><p>种群3的 预期比实际多45个纯合子，也可以理解为实际和预期相比有45个纯合子缺失，可能是远交或Wahlund效应导致。</p><p>第四步，计算每个亚群实际观察到的杂合度：</p><p>种群1: 250/500=0.5</p><p>种群2: 30/100=0.3</p><p>种群3: 500/1000=0.5</p><p>第五步，计算每个亚群预期的杂合度：</p><p>第六步，计算每个亚群的近交系数：</p><p>F1=(0.5-0.5)/0.5=0 不近交，不远交</p><p>F2=(0.455-0.3)/0.455=0.341 存在近交情况，实际杂合子比预期的少</p><p>F3=(0.455-0.5)/0.455=-0.099 存在远交情况，实际杂合子比预期的多</p><p>第七步，计算在整个种群中等位基因A的频率：</p><p>第八步，计算在整个种群中等位基因a的频率：</p><p>第九步，计算三种杂合性指数：</p><p>HI(实际杂合度)</p><p>HS(亚群预计杂合度–通过每个亚群预计杂合度(亚群等位基因频率)来计算)</p><p>HT(种群预计杂合度–通过种群中预计等位基因频率来计算)</p><p>第十步，计算:</p><p>最后留两个思考题：</p><p>1，FIS 和 FIT 的如何理解？</p><p>2，FST一定为正么？</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="http://www.voidcn.com/article/p-mdkdczqg-bpz.html" target="_blank" rel="noopener">http://www.voidcn.com/article/p-mdkdczqg-bpz.html</a></p><p><a href="https://wenku.baidu.com/view/b19155ef70fe910ef12d2af90242a8956aecaa36.html" target="_blank" rel="noopener">https://wenku.baidu.com/view/b19155ef70fe910ef12d2af90242a8956aecaa36.html</a></p><p><a href="https://www.jianshu.com/p/b73a8d6233be" target="_blank" rel="noopener">https://www.jianshu.com/p/b73a8d6233be</a></p><p><a href="https://www.plob.org/article/21678.html" target="_blank" rel="noopener">https://www.plob.org/article/21678.html</a></p><p><a href="https://zhuanlan.zhihu.com/p/44307625" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/44307625</a></p><p><a href="http://www.360doc.com/content/18/0221/13/19913717_731200680.shtml" target="_blank" rel="noopener">http://www.360doc.com/content/18/0221/13/19913717_731200680.shtml</a></p><p><a href="http://blog.sina.com.cn/s/blog_4ab0b3390102viol.html" target="_blank" rel="noopener">http://blog.sina.com.cn/s/blog_4ab0b3390102viol.html</a></p><p><a href="http://userwww.sfsu.edu/efc/classes/biol710/amova/amova.htm" target="_blank" rel="noopener">http://userwww.sfsu.edu/efc/classes/biol710/amova/amova.htm</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> genetics </tag>
            
            <tag> population genetics </tag>
            
            <tag> arithmetic </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>tabplot函数</title>
      <link href="/2020/06/11/tabplot-han-shu/"/>
      <url>/2020/06/11/tabplot-han-shu/</url>
      
        <content type="html"><![CDATA[<p>首先用devtools安装</p><p>然后运行：</p><pre class=" language-R"><code class="language-R">library(tabplot)diamonds %>% head()tableplot(diamonds)</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> ggplot </tag>
            
            <tag> R </tag>
            
            <tag> data visualization </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>apply族函数</title>
      <link href="/2020/06/11/apply-zu-han-shu/"/>
      <url>/2020/06/11/apply-zu-han-shu/</url>
      
        <content type="html"><![CDATA[<p>其实也没必要记住这么多，不会用了查就行**</p><p>lapply<br>|<br>|-&gt; 简化版: sapply<br>| | -&gt; 可设置返回值模板: vapply<br>| |-&gt; 多变量版: mapply<br>|<br>|-&gt; 递归版: rapply</p><h2 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h2><ol><li>3个参数，(data，margin，FUN)</li><li>应用在matrix或array上</li></ol><h2 id="sweep"><a href="#sweep" class="headerlink" title="sweep"></a>sweep</h2><p>常常和apply一起用，sweep函数和apply函数相似，但是sweep主要用于array的计算，而apply更多的是矩阵和data.frame计算。</p><pre class=" language-R"><code class="language-R">> mean.att <- apply(attitude, 2, mean) #对attitude每一col取均值> sweep(attitude, 2, mean.att, FUN = "-") %>% head() #让attitude每一个值减去这列均值，这就是两个参数了，一个值，一个列均值      rating complaints privileges   learning     raises   critical   advance1 -21.633333      -15.6 -23.133333 -17.366667  -3.633333  17.233333  2.0666672  -1.633333       -2.6  -2.133333  -2.366667  -1.633333  -1.766667  4.0666673   6.366667        3.4  14.866667  12.633333  11.366667  11.233333  5.0666674  -3.633333       -3.6  -8.133333  -9.366667 -10.633333   9.233333 -7.9333335  16.366667       11.4   2.866667   9.633333   6.366667   8.233333  4.0666676 -21.633333      -11.6  -4.133333 -12.366667 -10.633333 -25.766667 -8.933333</code></pre><h2 id="tapply和aggregate"><a href="#tapply和aggregate" class="headerlink" title="tapply和aggregate"></a>tapply和aggregate</h2><p>tapply函数很有用，tapply的功能就是把数据按照某种分组，在每个组内进行某个运算。这个aggregate函数很像。我觉得还是aggregate好用。</p><pre class=" language-R"><code class="language-R">> aggregate(mtcars,by=list(mtcars$cyl,mtcars$gear),FUN=mean)...略> aggregate(mtcars,by=list(mtcars$gear),FUN=mean)  Group.1      mpg      cyl     disp       hp     drat       wt   qsec        vs        am1       3 16.10667 7.466667 326.3000 176.1333 3.132667 3.892600 17.692 0.2000000 0.00000002       4 24.53333 4.666667 123.0167  89.5000 4.043333 2.616667 18.965 0.8333333 0.66666673       5 21.38000 6.000000 202.4800 195.6000 3.916000 2.632600 15.640 0.2000000 1.0000000  gear     carb1    3 2.6666672    4 2.3333333    5 4.400000> aggregate(mtcars$qsec,by=list(mtcars$gear),FUN=mean)  Group.1      x1       3 17.6922       4 18.9653       5 15.640> aggregate(cbind(mpg,hp) ~ cyl+gear, FUN=mean)  cyl gear    mpg       hp1   4    3 21.500  97.00002   6    3 19.750 107.50003   8    3 15.050 194.16674   4    4 26.925  76.00005   6    4 19.750 116.50006   4    5 28.200 102.00007   6    5 19.700 175.00008   8    5 15.400 299.5000> tapply(mtcars$qsec,mtcars$gear, mean)     3      4      5 17.692 18.965 15.640 </code></pre><p><strong>还可以实现crosstable功能，这个很好用</strong></p><pre class=" language-R"><code class="language-R">> df <- data.frame(year=kronecker(2001:2003, rep(1,4)),                   loc=c('beijing','beijing','shanghai','shanghai'),                   type=rep(c('A','B'),6), sale=rep(1:12))> tapply(df$sale, df[,c('year','loc')], sum)      locyear   beijing shanghai  2001       3        7  2002      11       15  2003      19       23# 类似的aggregate就麻烦一些> aggregate(df$sale, by = list(df$year,df$loc),FUN= sum) %>% +     reshape2::dcast(Group.1~Group.2)  Group.1 beijing shanghai1    2001       3        72    2002      11       153    2003      19       23</code></pre><h2 id="sapply和lapply"><a href="#sapply和lapply" class="headerlink" title="sapply和lapply"></a>sapply和lapply</h2><ol><li>都只有两个参数，第一个参数是输入数据，第二个是函数。</li><li>都应用在一个vector或list上</li><li>sapply返回的是一个vector，但是lapply返回的是一个list。其实sapply可以理解成lapply的简化版，s就是simplify的意思。</li></ol><p>其它：为了让sapply返回array或matrix，simplify参数很好用。</p><pre class=" language-R"><code class="language-R">   sapply(1:5,function(x) matrix(x,2,2), simplify = "array")</code></pre><p>这两个sapply/lapply 常和unlist()，matrix()，as.dataframe()，函数一起使用</p><h2 id="mapply"><a href="#mapply" class="headerlink" title="mapply"></a>mapply</h2><ol><li>多变量版的sapply，很好用，m就是multi的意思。</li><li>返回值是vector或matrix</li></ol><p><img src="https://raw.githubusercontent.com/Castel-Tao/Picbed_PicGo/master/img/20200525153812.png" alt=""></p><p><strong>下面这段代码值得一看</strong></p><pre class=" language-R"><code class="language-R">Alco <- data.frame(AlcoholDrunk = c( "YES", "YES", "NO",  "YES", "YES", "YES", NA, "YES", "YES", "YES", "YES", "YES", "YES", "NO",  "NO",  "NO",  "NO", "YES"),                    AmountDrunk = c(3.0, 1.0,  NA ,3.0,  NA, 0.0,  NA, 0.0,  NA, 1.7,  NA,  NA, 0.0,  NA,  NA,  NA,  NA, 2.0))#这里AlcoholDrunk变量有三种类型的值，“YES”，表示有饮酒史；“NO”, 表示无饮酒史；NA, 表示数据不可获取。# alcohol函数实现的功能是：如果AlcoholDrunk是NA，直接返回NA，如果是NO，返回NO；否则返回AmountDrunk的数值。alcohol <- function(texVal, numVal){  if(is.na(texVal)) {return("NA")}  else if(texVal == "NO"){return("NO")}  else if(is.na(numVal)){return("amount Unknown")}  else {return(numVal)}}mapply(alcohol, Alco$AlcoholDrunk, Alco$AmountDrunk)  #两个变量</code></pre><h2 id="replicate"><a href="#replicate" class="headerlink" title="replicate"></a>replicate</h2><p>另外还有一个非常有用的函数<strong>replicate()</strong>，它可以将某个函数重复运行N次，常常用来生成较复杂的随机数。下面的例子即先建立一个函数，模拟扔两个骰子的点数之和，然后重复运行1000次。</p><pre class=" language-R"><code class="language-R"># 定义一个game函数game <- function() {n <- sample(1:6,2,replace=T) #这个sample()函数也挺有意思的，我想replicate()应该经常会和sample()连用return(sum(n))}replicate(n=1000,game())  #将game()函数重复运行1000次。</code></pre><h2 id="rapply"><a href="#rapply" class="headerlink" title="rapply"></a>rapply</h2><p>这个好像也非常有用</p><pre class=" language-R"><code class="language-R">rapply(list, FUN, classes="ANY", deflt=NULL, how=c("unlist", "replace", "list"), ...)</code></pre><p>rapply是递归版的lappy。基本原理是对list作遍历，如果其中有的元素仍然是list，则继续遍历；对于每个非list类型的元素，如果其类型是classes参数指定的类型之一，则调用FUN。classes=”ANY”表示匹配所有类型。</p><p>how参数用来指定操作方式，有三种：</p><p>a. “replace” 直接用调用FUN后的结果替换原list中原来的元素<br>b. “list” 新建一个list，元素类型在classes中的，调用FUN；不在classes中的类型，使用deflt。会保留原始list的结构。<br>c. “unlist” 相当于对”list”模式下的结果调用unlist(recursive=TRUE)</p><p><strong>看完下面的例子你就明白了</strong></p><pre class=" language-R"><code class="language-R">> lst <- list(a=list(aa=c(1:5), ab=c(0.1,0.2,0.25,0.3,0.33)),  #a list里两个元素+             b=list(ba=c(1:10)),   #b list里一个元素+             c=c('ha','m','k'))  #c 不是一个list； a,b,c共同构成了lst list> lst$a$a$aa[1] 1 2 3 4 5$a$ab[1] 0.10 0.20 0.25 0.30 0.33$b$b$ba [1]  1  2  3  4  5  6  7  8  9 10$c[1] "ha" "m"  "k" > rapply(lst, sum, how='list',classes = 'numeric')$a$a$aaNULL$a$ab[1] 1.18$b$b$baNULL$cNULL> rapply(lst, sum, how='unlist',classes = c('integer'))a.aa b.ba   15   55 > rapply(lst, sum, how='unlist',classes = c('integer','numeric')) a.aa  a.ab  b.ba 15.00  1.18 55.00 > rapply(lst, sum, how='unlist',classes = c('integer','numeric'),deflt="This is deflt")           a.aa            a.ab            b.ba               c            "15"          "1.18"            "55" "This is deflt" > rapply(lst, nchar, how='unlist',classes = "character", deflt="DEFLT")   a.aa    a.ab    b.ba      c1      c2      c3 "DEFLT" "DEFLT" "DEFLT"     "2"     "1"     "1" </code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> R </tag>
            
            <tag> data cleaning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用Figures</title>
      <link href="/2020/06/10/chang-yong-figures/"/>
      <url>/2020/06/10/chang-yong-figures/</url>
      
        <content type="html"><![CDATA[<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=1441226072&auto=1&height=66"></iframe><h2 id="How-to-output"><a href="#How-to-output" class="headerlink" title="How to output ?"></a>How to output ?</h2><pre class=" language-R"><code class="language-R"># 第一种png("./Figures/cor.all.png",width = 1350,height = 1350,units = "px")pndev.off()# 第二种ggsave("c:/Users/TAOTAO/Desktop/Taimu.mountain/Diff_Finger_radar.png",width = 380,height = 380,units = 'mm')# 第三种library(export)graph2pdf(x=x, file=filen, aspectr=2, font = "Arial",             height = 5, bg = "transparent")graph2ppt(x=x, file=filen, vector.graphic=FALSE, width=9,           aspectr=sqrt(2), append = TRUE)graph2png(file=filen, fun=plot.fun, dpi=400, height = 5, aspectr=4)</code></pre><h2 id="Barplot"><a href="#Barplot" class="headerlink" title="Barplot"></a>Barplot</h2><pre class=" language-R"><code class="language-R">ggplot(cor.box,aes(x=project,y=value,fill=variable))+          geom_bar(stat = "identity",position = position_dodge(),width=0.7) +          geom_errorbar(aes(ymin=value-sd,ymax=value+sd),                        width=0.3, position=position_dodge(0.7))+ #bar֮??????          theme_bw() + scale_fill_npg() +           #scale_y_continuous(breaks = c(0,0.2,0.4,0.6,0.8,0.9,0.95,1.0),                   #  labels = c(0,0.2,0.4,0.6,0.8,0.9,0.95,1.0))+          geom_text(aes(label = round(cor.box$value,3)),vjust = 3,size=5,                    position = position_dodge(0.9))+          theme(axis.text = element_text(size =15),                axis.title = element_text(family ="Myriad",size=18),                legend.title = element_text(family ="Myriad",size=18,hjust = 0.5),                legend.text = element_text(size=15)                ) +          labs(x = "Projects", y = "Median Correlation of Log2 Intensity \n MCLI",                fill = "Sample")</code></pre><h2 id="Radar-plot"><a href="#Radar-plot" class="headerlink" title="Radar plot"></a>Radar plot</h2><pre class=" language-R"><code class="language-R">#Radar functioncoord_radar <- function (theta = "x", start = 0, direction = 1) {  theta <- match.arg(theta, c("x", "y"))r <- if (theta == "x")   "y"else "x"ggproto("CoordRadar", CoordPolar, theta = theta, r = r, start = start,         direction = sign(direction),        is_linear = function(coord) TRUE)}#names(hehe) <- c("organ","tea","tem_scaled")hehe %>%     ggplot(aes(x=organ, y=tem_scaled,group=tea, fill=tea,color=tea))+    geom_polygon(color="black",alpha=.1,size=0.5) +    geom_point(size=4,shape=21,alpha=.5)+    coord_radar() +    theme_bw() +    #facet_wrap(~variable,nrow=2) +    scale_fill_manual(values = c("#3d3b4f",'#4c8dae','#2edfa3','#dc3023','#b0a4e3','#f2be45','#3eede7')) +    scale_color_manual(values = c("#3d3b4f",'#4c8dae','#2edfa3','#dc3023','#b0a4e3','#f2be45','#3eede7')) +    theme(        axis.title=element_text(size=30,face="plain",color="black"),        axis.text = element_text(size=24,face="plain",color="black",angle = myAngle),        panel.grid.major = element_line(color="grey80"),        axis.line = element_line(color="black"),        axis.ticks =  element_line(color="black"),        legend.text = element_text(size=24))</code></pre><p><img src="https://raw.githubusercontent.com/Castel-Tao/Picbed_PicGo/master/img/20200524140546.png" alt=""></p><h2 id="Boxplot"><a href="#Boxplot" class="headerlink" title="Boxplot"></a>Boxplot</h2><h3 id="箱线图"><a href="#箱线图" class="headerlink" title="箱线图"></a>箱线图</h3><pre class=" language-R"><code class="language-R">gg_data %>% ggplot(aes(x= diff, y= temperature, color= tea))+    geom_boxplot(size = 1.2) +     theme_bw() +  my.theme +    scale_color_manual(values = c("#3d3b4f",'#4c8dae','#2edfa3','#dc3023','#b0a4e3','#f2be45','#3eede7')) +    labs(title = "Temperature Difference of Finger Front ")</code></pre><p><img src="https://raw.githubusercontent.com/Castel-Tao/Picbed_PicGo/master/img/20200524141112.png" alt=""></p><h3 id="云雨图"><a href="#云雨图" class="headerlink" title="云雨图"></a>云雨图</h3><pre class=" language-R"><code class="language-R">library(ggplot2)library(dplyr)"%||%" <- function(a, b) {  if (!is.null(a)) a else b}geom_flat_violin <- function(mapping = NULL, data = NULL, stat = "ydensity",                        position = "dodge", trim = TRUE, scale = "area",                        show.legend = NA, inherit.aes = TRUE, ...) {  layer(    data = data,    mapping = mapping,    stat = stat,    geom = GeomFlatViolin,    position = position,    show.legend = show.legend,    inherit.aes = inherit.aes,    params = list(      trim = trim,      scale = scale,      ...    )  )}#' @rdname ggplot2-ggproto#' @format NULL#' @usage NULL#' @exportGeomFlatViolin <-  ggproto("GeomFlatViolin", Geom,          setup_data = function(data, params) {            data$width <- data$width %||%              params$width %||% (resolution(data$x, FALSE) * 0.9)            # ymin, ymax, xmin, and xmax define the bounding rectangle for each group            data %>%              group_by(group) %>%              mutate(ymin = min(y),                     ymax = max(y),                     xmin = x,                     xmax = x + width / 2)          },          draw_group = function(data, panel_scales, coord) {            # Find the points for the line to go all the way around            data <- transform(data, xminv = x,                              xmaxv = x + violinwidth * (xmax - x))            # Make sure it's sorted properly to draw the outline            newdata <- rbind(plyr::arrange(transform(data, x = xminv), y),                             plyr::arrange(transform(data, x = xmaxv), -y))            # Close the polygon: set first and last point the same            # Needed for coord_polar and such            newdata <- rbind(newdata, newdata[1,])            ggplot2:::ggname("geom_flat_violin", GeomPolygon$draw_panel(newdata, panel_scales, coord))          },          draw_key = draw_key_polygon,          default_aes = aes(weight = 1, colour = "grey20", fill = "white", size = 0.5,                            alpha = NA, linetype = "solid"),          required_aes = c("x", "y"))#gg_data %>% dplyr::filter(diff == "F5-F4") %>% ggplot(aes(x= tea, y= temperature, fill=tea,color=tea))+    geom_flat_violin(position= position_nudge(x=.25)) +     geom_jitter(width = .1 )+    geom_boxplot(width = .1, position= position_nudge(x=.25), fill="white",size=.5,color="black") +     theme_bw() +  my.theme +    scale_color_manual(values = c("#3d3b4f",'#4c8dae','#2edfa3','#dc3023','#b0a4e3','#f2be45','#3eede7')) +    scale_fill_manual(values = c("#3d3b4f",'#4c8dae','#2edfa3','#dc3023','#b0a4e3','#f2be45','#3eede7')) +    labs(title = "Temperature Difference of Finger F5-F4 ")</code></pre><p><img src="https://raw.githubusercontent.com/Castel-Tao/Picbed_PicGo/master/img/20200524140914.png" alt=""></p><h2 id="Lineplot"><a href="#Lineplot" class="headerlink" title="Lineplot"></a>Lineplot</h2><p><img src="https://raw.githubusercontent.com/Castel-Tao/Picbed_PicGo/master/img/20200524144155.png" alt="">****</p><pre class=" language-R"><code class="language-R">gg_data_1 <- read_csv("c:/Users/TAOTAO/Desktop/R.Code/Always/LinePlot.csv")gg_data_1 %>%             ggplot(aes(y=tem_scaled,x=part, color=tea, shape=tea))+                geom_point(size = 4,alpha=.8) +                 theme_bw() +                 scale_color_manual(values = c("#3d3b4f",'#4c8dae','#2edfa3','#dc3023','#b0a4e3','#f2be45','#3eede7')) +        geom_line(data=gg_data_1[which(gg_data_1$group_1=="R"),],                 aes(group=factor(JingLuo), linetype= factor(Jingluo)), size=1.4,alpha = .6) +      geom_line(data=gg_data_1[which(gg_data_1$group_1=="L"),],                 aes(group=factor(JingLuo), linetype= factor(Jingluo)), size=1.4,alpha = .6) </code></pre><p><img src="https://raw.githubusercontent.com/Castel-Tao/Picbed_PicGo/master/img/20200524141154.png" alt=""></p><pre class=" language-R"><code class="language-R">hehe %>%  ggplot(aes(x=number,y=value,color=variable)) +   geom_line(lwd=2) +  #,linetype = "dashed"  theme_bw() + scale_color_npg() +  scale_x_continuous(breaks = POG.df$number,labels = POG.df$gene.rank)+  scale_y_continuous(breaks = c(0.2,0.4,0.6,0.7,0.8,0.85,0.9,0.95),                     labels = c(0.2,0.4,0.6,0.7,0.8,0.85,0.9,0.95))+  theme(axis.text.x = element_text(angle = 30,vjust = 0.4))+  xlab("Gene ranking")+  ylab("Percentage of Overlapped Genes")  #geom_point(position = position_dodge(.2), size = 2)</code></pre><p><img src="https://raw.githubusercontent.com/Castel-Tao/Picbed_PicGo/master/img/20200524141236.png" alt=""></p><pre class=" language-R"><code class="language-R">tmp %>% dplyr::filter(type=="A") %>% ggplot(aes(x = variable,y=value,fill=Percentile,color=Date)) +   geom_line(lwd=3) +   ylab("Mean Covrage")+  xlab("Normalized Position")+  theme_bw() + scale_color_nejm() +  theme(axis.title = element_text(size=25),        axis.text = element_text(size =25),        legend.text = element_text(size=20), #图例文字        legend.title = element_text(size=25,hjust = 0.5))</code></pre><p><img src="https://raw.githubusercontent.com/Castel-Tao/Picbed_PicGo/master/img/20200524141303.png" alt=""></p><h2 id="Scatter-plot"><a href="#Scatter-plot" class="headerlink" title="Scatter plot"></a>Scatter plot</h2><p>相关性矩阵图</p><pre class=" language-R"><code class="language-R">HEHE2 %>% pheatmap(show_rownames = T,           show_colnames = T,          cluster_rows = F,          cluster_cols = F,           display_numbers = TRUE,  #是否显示格子数值           number_color = "grey29",  #格子数值颜色           cutree_rows = 1,           cutree_cols = 1,           cellwidth = 45, cellheight = 45,           #annotation_col = col_anno,           #annotation_colors = ann_colors,          #annotation_row = col_anno,           border_color = F,   #调整格子边缘           main = paste0("Correlation Matrix of all Sample"),      #标题           fontsize=15                   #标题size           )</code></pre><p><img src="https://raw.githubusercontent.com/Castel-Tao/Picbed_PicGo/master/img/20200524144202.png" alt=""></p><p><img src="https://raw.githubusercontent.com/Castel-Tao/Picbed_PicGo/master/img/20200524144533.png" alt=""></p><h2 id="Paired-Scatter-Plot"><a href="#Paired-Scatter-Plot" class="headerlink" title="Paired Scatter Plot"></a>Paired Scatter Plot</h2><pre class=" language-R"><code class="language-R">library(GGally)panel.points <- function(data, mapping){  ggplot(data = data, mapping = mapping) +    geom_point(alpha=0.4,size=1.3,color='#177cb0')+ #3C5488FF    geom_abline(intercept = 0 , slope = 1 , color='#c93756', linetype='dashed', size=1)    #scale_x_continuous(limits=c(-7,17))+    #scale_y_continuous(limits=c(-7,17))}pn <- ggpairs(tmp2[7:ncol(tmp2)],mapping = ggplot2::aes(),  #title = paste0("Paired Scatter plot; ",i,"; ",format," 3000 genes"),  lower = list(continuous = panel.points),  #diag = list(continuous='barDiag'),  upper = list(    continuous = function(data, mapping, ...){    ggally_cor(data = data, mapping = mapping, size= 10)}    ) ) +  theme_light() +  theme(legend.position = "none",         panel.grid.major = element_blank(),         axis.ticks = element_blank(),         strip.text = element_text(size =20), #调节小面标签大小        axis.text = element_text(size =15), #调节坐标轴字体大小        panel.border = element_rect(colour = "black", fill = NA))</code></pre><p><img src="https://raw.githubusercontent.com/Castel-Tao/Picbed_PicGo/master/img/20200524144046.png" alt=""></p><h2 id="Density-plot"><a href="#Density-plot" class="headerlink" title="Density plot"></a>Density plot</h2><pre class=" language-R"><code class="language-R">tmptmp %>%     ggplot(aes(x=value,fill=Sample_library,color=Sample_library)) +       geom_density(alpha=0.3,size=1.2) +       theme_bw() + scale_fill_nejm() + scale_color_nejm()+        labs(title = "Globle gene expression level",x= "log2 TPM")</code></pre><p><img src="https://raw.githubusercontent.com/Castel-Tao/Picbed_PicGo/master/img/20200524144111.png" alt=""></p><h2 id="VeenDiagram"><a href="#VeenDiagram" class="headerlink" title="VeenDiagram"></a>VeenDiagram</h2><pre class=" language-R"><code class="language-R">library (VennDiagram)venn.diagram(x=list(AGR=top2000.AGR, NVS=top2000.NVS,WuXi=top2000.WuX_Poly,ARD=top2000.ARD_Poly),                "NT_Consensus_Diff_Platform.png", height = 2000, width = 2000,                resolution =900, imagetype="png",col="gray",               fill=c("#574266","#bddd22","#ff2d51","#3eede7"),                alpha=c(0.6, 0.6,0.6,0.6), lwd=0.5, cex=0.4, #lwd调节线条宽度,cex=0了文字就没有了，                                                                      #cex调节里面的标注大小               cat.dist=c(-0.07, -0.07, -0.05,-0.07),                cat.pos=c(100, 260, 0,150),cat.cex=0.45, cat.col="black", #cat.调节数据集名称，                                                                     #cat.col和.pos似乎也可有可无               rotation.degree=180)    #rotation.degree是旋转角度的意思，可有可无</code></pre><p><img src="https://raw.githubusercontent.com/Castel-Tao/Picbed_PicGo/master/img/20200524144105.png" alt=""></p><h2 id="PCA"><a href="#PCA" class="headerlink" title="PCA"></a>PCA</h2><pre class=" language-R"><code class="language-R"># PCA ---------------------------------------------------------------------tmp %>% tail()tmp2 <- tmp %>% dcast(gene~Single_ID) tmp2 %>% dim()#然后PCA作图展示结果pc.cr <- prcomp(t(log2(tmp2[,-1] + 0.01)),retx = TRUE)pc <- round(summary(pc.cr)$importance[2,],2) pca.result <- as.data.frame(pc.cr$x[,1:2])tmp1 <- tmp %>% dplyr::select(Single_ID,sample,library,year,project)hehe <- tmp1 %>% group_by(Single_ID,library,sample,project) %>% summarise() %>% as.data.frame()pca.result <- cbind(hehe,pca.result)pca.result %>% head()##PCA按照样本类型，建库策略分开pn <- ggplot(pca.result,aes(x=PC1,y=PC2,color=sample,shape=library))+      geom_point(size = 6,alpha=0.5) +       theme_bw() + scale_color_nejm() +      xlab(paste0("PC1  ",pc[1])) +      ylab(paste0("PC2  ",pc[2])) ### 3D pcalibrary(rgl)pca.result.3d <- as.data.frame(pc.cr$x[,1:3])pca.result.3d <- cbind(hehe,pca.result.3d)pca.result.3d %>% headscales::show_col(pal_nejm("default")(8))pca.result.3d$color <- "#BC3C29FF"pca.result.3d$color[pca.result.3d$sample == "B"] <- "#0072B5FF"pca.result.3d$color[pca.result.3d$library == "PolyA"] <- "#E18727FF"pca.result.3d$color[pca.result.3d$library == "Ribo"] <- "#20854EFF"within(pca.result.3d,plot3d(PC1,PC2,PC3,size=10,col = color))</code></pre><p><img src="https://raw.githubusercontent.com/Castel-Tao/Picbed_PicGo/master/img/20200524144134.png" alt=""></p><h2 id="HCA"><a href="#HCA" class="headerlink" title="HCA"></a>HCA</h2><pre class=" language-R"><code class="language-R">sample[sample == "A"] <- "#BC3C29FF"  #红sample[sample == "B"] <- "#0072B5FF"library[library == "Ribo"] <- "#E18727FF"   #黄library[library == "PolyA"] <- "#20854EFF"  #绿color <-  data.frame(library,sample) %>% as.matrix()myclust <- function(x){hclust(x,method="average")}library("gplots")library("heatmap.plus")showpanel <- function(col){  image(z=matrix(1:100, ncol=1), col=col, xaxt="n", yaxt="n" )}showpanel(colorpanel(25,"#BC3C29FF","white","#0072B5FF"))heatmap.plus(as.matrix(center), col=colorpanel(15,"#0072B5FF","white","#BC3C29FF"),             labRow=F,labCol = F,             scale="none", hclustfun=myclust, ColSideColors=color,          key=F, symkey=FALSE, dendrogram=c("none"),          density.info="none", trace="none", cexRow=0.5)library(export)graph2png(file="hehe.png",width=7,height=7)require(graphics)hc <- hclust(dist(t(as.matrix(center))),"average")plot(hc,axes = F)</code></pre><p><img src="https://raw.githubusercontent.com/Castel-Tao/Picbed_PicGo/master/img/20200524144116.png" alt=""></p><h2 id="火山图"><a href="#火山图" class="headerlink" title="火山图"></a>火山图</h2><pre class=" language-R"><code class="language-R"># 设置pvalue和logFC的阈值cut_off_pvalue = 0.05cut_off_logFC = 1# 根据阈值分别为上调基因设置‘up’，下调基因设置‘Down’，无差异设置‘Stable’，保存到change列data$change = ifelse(data$qvalue < cut_off_pvalue & abs(data$log2.fc.) >= cut_off_logFC,                      ifelse(data$log2.fc.> cut_off_logFC ,'Up','Down'),'Stable')# 作图data %>% ggplot(aes(x= log2.fc. ,y=-log10(qvalue),color = change)) +  geom_point(aes(size = Abundance),alpha = 0.5 ) +   labs(x = "log2 fold change", y = "-log10(qvalue) \n") +    xlim(-4,4) + ylim(0,8) +           geom_hline(yintercept = -log10(0.05),lty=4,lwd=0.6,alpha=0.8) +    geom_vline(xintercept = c(1,-1),lty=4,lwd=0.6,alpha=0.8) +  theme_classic() +   scale_color_manual(values=c("#546de5", "#d2dae2","#ff4757"))</code></pre><p><img src="https://raw.githubusercontent.com/Castel-Tao/Picbed_PicGo/master/img/20200524144832.png" alt=""></p><h2 id="火山图2"><a href="#火山图2" class="headerlink" title="火山图2"></a>火山图2</h2><pre class=" language-R"><code class="language-R">data <- read.csv( "C:../asset/wuli.csv")data$Abundance <- (data$Y179.30 + data$Y179.40)/1000# 设置pvalue和logFC的阈值cut_off_pvalue = 0.05cut_off_logFC = 1# 根据阈值分别为上调基因设置‘up’，下调基因设置‘Down’，无差异设置‘Stable’，保存到change列data$change = ifelse(data$qvalue < cut_off_pvalue & abs(data$log2.fc.) >= cut_off_logFC,                      ifelse(data$log2.fc.> cut_off_logFC ,'Up','Down'),'Stable')# 作图pn <- data %>% ggplot(aes(x= log2.fc. ,y=-log10(qvalue),color = change)) +  geom_point(aes(size = Abundance),alpha = 0.5 ) +   labs(x = "log2 fold change", y = "-log10(qvalue) \n") +    xlim(-4,4) + ylim(0,8) +           geom_hline(yintercept = -log10(0.05),lty=4,lwd=0.6,alpha=0.8) +    geom_vline(xintercept = c(1,-1),lty=4,lwd=0.6,alpha=0.8) +  theme_classic() +   scale_color_manual(values=c("#546de5", "#d2dae2","#ff4757"))# 标记labeldata$label = ifelse(data$qvalue < cut_off_pvalue & abs(data$log2.fc.) >= 2.5,                        as.character(data$Geneid),"")library(ggrepel)pn + geom_text_repel(data = data, aes(x = data$log2.fc.,                                       y = -log10(data$qvalue),                                       label = label),                  size = 3,box.padding = unit(0.5, "lines"),                  point.padding = unit(0.8, "lines"),                   segment.color = "black",                   show.legend = FALSE)</code></pre><p><img src="https://raw.githubusercontent.com/Castel-Tao/Picbed_PicGo/master/img/20200531165613.png" alt=""></p>]]></content>
      
      
      
        <tags>
            
            <tag> ggplot </tag>
            
            <tag> R </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
